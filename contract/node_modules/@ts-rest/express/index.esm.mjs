import { ZodErrorSchema, isAppRoute, TsRestResponseError, validateResponse, isAppRouteNoBody, isAppRouteOtherResponse, checkZodSchema, parseJsonQueryObject } from '@ts-rest/core';
import { z } from 'zod';
import { Stream } from 'stream';

const isAppRouteImplementation = (obj) => {
    return typeof obj === 'function';
};

class RequestValidationError extends Error {
    constructor(pathParams, headers, query, body) {
        super('[ts-rest] request validation failed');
        this.pathParams = pathParams;
        this.headers = headers;
        this.query = query;
        this.body = body;
    }
}
z.object({
    pathParameterErrors: ZodErrorSchema.nullable(),
    headerErrors: ZodErrorSchema.nullable(),
    queryParameterErrors: ZodErrorSchema.nullable(),
    bodyErrors: ZodErrorSchema.nullable(),
});

const initServer = () => {
    return {
        router: (contract, router) => router,
        route: (contract, route) => route,
    };
};
const recursivelyApplyExpressRouter = ({ schema, router, processRoute, }) => {
    if (typeof router === 'object' && typeof (router === null || router === void 0 ? void 0 : router.handler) !== 'function') {
        for (const key in router) {
            if (isAppRoute(schema)) {
                throw new Error(`[ts-rest] Expected AppRouter but received AppRoute`);
            }
            recursivelyApplyExpressRouter({
                schema: schema[key],
                router: router[key],
                processRoute,
            });
        }
    }
    else if (typeof router === 'function' ||
        typeof (router === null || router === void 0 ? void 0 : router.handler) === 'function') {
        if (!isAppRoute(schema)) {
            throw new Error(`[ts-rest] Expected AppRoute but received AppRouter`);
        }
        processRoute(router, schema);
    }
};
const validateRequest = (req, res, schema, options) => {
    const paramsResult = checkZodSchema(req.params, schema.pathParams, {
        passThroughExtraKeys: true,
    });
    const headersResult = checkZodSchema(req.headers, schema.headers, {
        passThroughExtraKeys: true,
    });
    const query = options.jsonQuery
        ? parseJsonQueryObject(req.query)
        : req.query;
    const queryResult = checkZodSchema(query, schema.query);
    const bodyResult = checkZodSchema(req.body, 'body' in schema ? schema.body : null);
    if (!paramsResult.success ||
        !headersResult.success ||
        !queryResult.success ||
        !bodyResult.success) {
        throw new RequestValidationError(!paramsResult.success ? paramsResult.error : null, !headersResult.success ? headersResult.error : null, !queryResult.success ? queryResult.error : null, !bodyResult.success ? bodyResult.error : null);
    }
    return {
        paramsResult,
        headersResult,
        queryResult,
        bodyResult,
    };
};
const initializeExpressRoute = ({ implementationOrOptions, schema, app, options, }) => {
    if (options.logInitialization) {
        console.log(`[ts-rest] Initialized ${schema.method} ${schema.path}`);
    }
    const handler = isAppRouteImplementation(implementationOrOptions)
        ? implementationOrOptions
        : implementationOrOptions.handler;
    const mainReqHandler = async (req, res, next) => {
        try {
            const validationResults = validateRequest(req, res, schema, options);
            let result;
            try {
                result = await handler({
                    params: validationResults.paramsResult.data,
                    body: validationResults.bodyResult.data,
                    query: validationResults.queryResult.data,
                    headers: validationResults.headersResult.data,
                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                    // @ts-ignore
                    files: req.files,
                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                    // @ts-ignore
                    file: req.file,
                    req: req,
                    res: res,
                });
            }
            catch (e) {
                if (e instanceof TsRestResponseError) {
                    result = {
                        status: e.statusCode,
                        body: e.body,
                    };
                }
                else {
                    throw e;
                }
            }
            const statusCode = Number(result.status);
            if (result.body instanceof Stream) {
                return result.body.pipe(res.status(result.status));
            }
            let validatedResponseBody = result.body;
            if (options.responseValidation) {
                const response = validateResponse({
                    appRoute: schema,
                    response: {
                        status: statusCode,
                        body: result.body,
                    },
                });
                validatedResponseBody = response.body;
            }
            const responseType = schema.responses[statusCode];
            if (isAppRouteNoBody(responseType)) {
                return res.status(statusCode).end();
            }
            if (isAppRouteOtherResponse(responseType)) {
                res.setHeader('content-type', responseType.contentType);
                return res.status(statusCode).send(validatedResponseBody);
            }
            return res.status(statusCode).json(validatedResponseBody);
        }
        catch (e) {
            return next(e);
        }
    };
    const handlers = [
        (req, res, next) => {
            req.tsRestRoute = schema;
            next();
        },
    ];
    if (options.globalMiddleware) {
        handlers.push(...options.globalMiddleware);
    }
    if (!isAppRouteImplementation(implementationOrOptions) &&
        implementationOrOptions.middleware) {
        handlers.push(...implementationOrOptions.middleware);
    }
    handlers.push(mainReqHandler);
    switch (schema.method) {
        case 'GET':
            app.get(schema.path, ...handlers);
            break;
        case 'DELETE':
            app.delete(schema.path, ...handlers);
            break;
        case 'POST':
            app.post(schema.path, ...handlers);
            break;
        case 'PUT':
            app.put(schema.path, ...handlers);
            break;
        case 'PATCH':
            app.patch(schema.path, ...handlers);
            break;
    }
};
const requestValidationErrorHandler = (handler = 'default') => {
    return (err, req, res, next) => {
        if (err instanceof RequestValidationError) {
            // old-style error handling, kept for backwards compatibility
            if (handler === 'default') {
                if (err.pathParams) {
                    return res.status(400).json(err.pathParams);
                }
                if (err.headers) {
                    return res.status(400).json(err.headers);
                }
                if (err.query) {
                    return res.status(400).json(err.query);
                }
                if (err.body) {
                    return res.status(400).json(err.body);
                }
            }
            else if (handler === 'combined') {
                return res.status(400).json({
                    pathParameterErrors: err.pathParams,
                    headerErrors: err.headers,
                    queryParameterErrors: err.query,
                    bodyErrors: err.body,
                });
            }
            else {
                return handler(err, req, res, next);
            }
        }
        next(err);
    };
};
const createExpressEndpoints = (schema, router, app, options = {
    logInitialization: true,
    jsonQuery: false,
    responseValidation: false,
    requestValidationErrorHandler: 'default',
}) => {
    recursivelyApplyExpressRouter({
        schema,
        router,
        processRoute: (implementation, innerSchema) => {
            initializeExpressRoute({
                implementationOrOptions: implementation,
                schema: innerSchema,
                app,
                options,
            });
        },
    });
    app.use(requestValidationErrorHandler(options.requestValidationErrorHandler));
};

export { RequestValidationError, createExpressEndpoints, initServer };
